---
title: "Helium"
author: "Thomas de Marchin"
date: "January 2022"
output: 
  html_document:
    number_sections: true
---

```{r setup, include=FALSE}
rm(list=ls())
knitr::opts_chunk$set(echo = T, warning = F, message = F, cache = T, out.width = '100%')
```

**Thomas is Senior Data Scientist at Pharmalex. He is passionate about the incredible possibility that blockchain technology offers to make the world a better place. You can contact him on [Linkedin](https://www.linkedin.com/in/tdemarchin/) or [Twitter](https://twitter.com/tdemarchin).**

**Milana is Data Scientist at Pharmalex. She is passionate about the power of analytical tools to discover the truth about the world around us and guide decision making. You can contact her on [Linkedin](https://www.linkedin.com/in/mfilatenkova/).**

# Introduction

To fetch the data, we can:

  - Set-up an ETL
  - Download data from the Metabase Dewi ETL
  - Use the API
  - Download data dump from http://18.212.212.108:8000/ 

# Data

```{r}
# First, let's load a few useful packages
library(knitr)
library(tidyverse)
library(data.table)
library(ggplot2)
library(gganimate)
library(hexbin)
library(h3)
library(lubridate)
```

fread from the data.table package is similar to read.table but much faster and more convenient. It takes care of decompressing files automatically.

When you work with big data, the key is to eliminate the data you don't need to save memory.

```{r}
### Retrieve transferred data packed data
listFilesPackets <- list.files("data/packets", pattern=".csv.gz", recursive = T)

# We specify the columns we want to keep directly in the fread call to save memory
# dataPackets <- lapply(1:length(listFilesPackets),function(i){
dataPackets <- lapply(1:2,function(i){
  
  print(i)
  data <- fread(file = paste0("data/packets/",listFilesPackets[i]), select = c("block", "transaction_hash", "time", "gateway", "num_dcs")) 
  
  return(data)
})

dataPackets <- dplyr::bind_rows(dataPackets) %>%
  mutate(bytes = 24 * num_dcs, # Every 24 bytes sent in an uplink or downlink packet cost 1 DC = $.00001.
         date = as.POSIXct(time, origin = "1970-01-01")) %>%
  mutate_at(c("transaction_hash", "gateway"), as.factor) %>%
  select(-time, -num_dcs) %>%
  rename(hotspot = gateway) 

dataPackets <- distinct(dataPackets) #TODO find outs why there are so many duplicated rows in the data
```

Now, we need to add the location of the hotspots. Helium use a system called H3. H3 is a geospatial indexing system using a hexagonal grid that can be (approximately) subdivided into finer and finer hexagonal grids. Instead of working with longitude and latitude, hotspots are positionned in hexagons. This approach is very useful and we could in theory work with the H3 indexing. Plotting functions in R are however more adapted to work with latitudes and longitudes so we will have to convert H3 to this. Note that below, we will reconvert these coordinate in hexagons. There is probably a way to skip that part. 

```{r}
### Retrieve info on the gateway
dataGateway <- fread(file = "data/gateway_inventory_01213771.csv.gz") %>%
  select(address, owner, first_timestamp, location_hex) %>%
  rename(hotspot = address,
         firstDate = first_timestamp) %>%
  filter(location_hex != "", # remove hotspots without location
         firstDate != as.POSIXct("1970-01-01 00:00:00", tz = "UTC"))  %>% # a few hotspots appears to have been installed in 1970. This is obviously a mistake in the data base.
  mutate(data.frame(h3_to_geo(location_hex))) # convert h3 to lat and lng
```

First info we can get is the number of hotspot per owner. 
```{r}
nHotspotsPerOwner <- dataGateway %>% 
  group_by(owner) %>%
  summarise(count = n()) %>%
  arrange(desc(count))

nHotspotsPerOwner
```

If we plot an histogram of the count, it will be difficult to visualize anything. Indeed, the distribution is hyper skewed. Most owner have only 1-2 hotspots but some have more than 100, up to 2000 (who are they?). To visualize the distribution, we will here restrict the the number of owner with less than 100 hotspots.
```{r}
ggplot(filter(nHotspotsPerOwner, count <= 100), aes(count)) +
   geom_histogram(bins = 100) +
   scale_y_continuous(trans='log10') 
```

We can also visualize the growth of the network in terms of number of hotspots. 

```{r}
nHotspotsPerDate <- dataGateway %>% 
  group_by(firstDate) %>%
  summarise(count = n()) 

ggplot(nHotspotsPerDate, aes(x = firstDate, y = cumsum(count))) +
  geom_line() +
  labs(title = "Growth of the hotspots", 
       y = "Total number of hotspot",
       x = "First apparition on the network") +
  scale_y_continuous(labels = function(x) format(x, scientific = FALSE),
                     breaks = seq(0, 5*10^5, length = 6))
```


Combine all data

```{r}
dataPacketsWithLocation <- inner_join(dataPackets, dataGateway) # combine the two dataset by keeping all rows both in X and Y
```



The client is the hotspot that witnessed the data packet and the owner is the wallet that paid for the data packet.

# Create a map

```{r}
world <- map_data("world")

map <- ggplot() +
  geom_map(
    data = world, map = world,
    aes(long, lat, map_id = region)
  ) 
  
map
```
https://stackoverflow.com/questions/46556375/how-to-convert-x-y-coordinates-to-hexbin-center-coordinates

```{r}
makeHexData <- function(df) {
 h <- hexbin(df$lng, df$lat, nbins, xbnds = xbnds, ybnds = ybnds, IDs = TRUE)
 data.frame(hcell2xy(h),
            bytesPerDay = tapply(df$bytes, h@cID, FUN = function(z) sum(z)),
            cid = h@cell)
}

## find the bounds for the complete data 
xbnds <- range(dataPacketsWithLocation$lng)
ybnds <- range(dataPacketsWithLocation$lat)
nbins <- 100

dataHexagon <- dataPacketsWithLocation %>%
  group_by(date) %>%
  group_modify(~ makeHexData(.x))

pBytesPerDay <- map +
    geom_hex(aes(x = x, y = y, fill = log10(bytesPerDay)),
             stat = "identity", 
             alpha = 0.8,
             data = dataHexagon) +
    scale_fill_gradientn (colours = c("green","red")) 

anim <- pBytesPerDay + 
  transition_states(as.factor(date)) +
  labs(title = "Date: {closest_state}",
          subtitle = 'Frame {frame} of {nframes}') 

animate(anim, nframes = 8)
```



```{r}

```

Now we will overlay the Helium data:

https://aberdeenstudygroup.github.io/studyGroup/lessons/Visualising%20Spatial%20Data/Visualising_Spatial_Data_in_R/
https://ghanadatastuff.com/post/3d_population_density/

```{r}
mapScatter <- map +
  geom_point(
    data = dataCreditWithLocation[1:10000,],
    aes(Long, Lat),
    color = "green",
    alpha = 0.7, 
    size = 0.01)

mapPolygon <- map +
  stat_density_2d(
    data = dataCreditWithLocation[1:10000,],
    aes(x = Long, y = Lat, fill = ..level..),
    geom = "polygon") + scale_fill_gradient2(low = "blue", 
                       mid = "green", 
                       high = "red")
mapPolygon
```

```{r}
# 
# fig <-  plot_ly(
#     type = 'densitymapbox',
#     lat = ~Lat,
#     lon = ~Long,
#     z = ~ Packets,
#     frame = ~Time,
#     coloraxis = 'coloraxis',
#     data = dataCreditWithLocation[1:100000,],
#     radius = 1) %>%
#   layout(
#     mapbox = list(
#       style="stamen-terrain",
#       center= list(lon=180)), 
#     coloraxis = list(colorscale = "Viridis"))
# 
# fig
# 
# fig <-  plot_ly(
#     type = 'scattermapbox',
#     lat = ~Lat,
#     lon = ~Long,
#     frame = ~Time,
#     color = ~log(Packets),
#     data = dataCreditWithLocation[1:100000,]) %>%
#   layout(
#     mapbox = list(
#       style="stamen-terrain"))
# 
# fig
```


https://plotly-r.com/animating-views.html
https://datavizpyr.com/how-to-make-world-map-with-ggplot2-in-r/
https://towardsdatascience.com/exploring-the-helium-network-with-graph-theory-66cbb8bffff9