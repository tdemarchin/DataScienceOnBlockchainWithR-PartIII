---
title: "Helium"
author: "Thomas de Marchin"
date: "January 2022"
output: 
  html_document:
    number_sections: true
---

```{r setup, include=FALSE}
rm(list=ls())
knitr::opts_chunk$set(echo = T, warning = F, message = F, cache = T, out.width = '100%')
```

**Thomas is Senior Data Scientist at Pharmalex. He is passionate about the incredible possibility that blockchain technology offers to make the world a better place. You can contact him on [Linkedin](https://www.linkedin.com/in/tdemarchin/) or [Twitter](https://twitter.com/tdemarchin).**

**Milana is Data Scientist at Pharmalex. She is passionate about the power of analytical tools to discover the truth about the world around us and guide decision making. You can contact her on [Linkedin](https://www.linkedin.com/in/mfilatenkova/).**

# Introduction

To fetch the data, we can:

  - Set-up an ETL
  - Download data from the Metabase Dewi ETL
  - Use the API
  - Download data dump from http://18.212.212.108:8000/ 

```{r}
# First, let's load a few useful packages
library(knitr)
library(tidyverse)
library(data.table)
library(ggplot2)
library(gganimate)
library(hexbin)
library(h3)
library(lubridate)
```

# Data

## Packet data

fread from the data.table package is similar to read.table but much faster and more convenient. It takes care of decompressing files automatically.

When you work with big data, the key is to eliminate the data you don't need to save memory.

```{r}
### Retrieve transferred data packed data
listFilesPackets <- list.files("data/packets", pattern=".csv.gz", recursive = T)

# We specify the columns we want to keep directly in the fread call to save memory
# dataPackets <- lapply(1:length(listFilesPackets),function(i){
dataPackets <- lapply(1:6,function(i){
  
  print(i)
  data <- fread(file = paste0("data/packets/",listFilesPackets[i]), select = c("block", "transaction_hash", "time", "gateway", "num_dcs")) 
  
  return(data)
})

dataPackets <- dplyr::bind_rows(dataPackets) %>%
  mutate(bytes = 24 * num_dcs, # Every 24 bytes sent in an uplink or downlink packet cost 1 DC = $.00001.
         date = as.POSIXct(time, origin = "1970-01-01"),
         date = ceiling_date(date, "day")) %>% # reduce the precision of the date to ease the plotting
  mutate_at(c("transaction_hash", "gateway"), as.factor) %>%
  select(-time, -num_dcs) %>%
  rename(hotspot = gateway) 

dataPackets <- distinct(dataPackets) #TODO find outs why there are so many duplicated rows in the data
```

Now, we need to add the location of the hotspots. Helium use a system called the Uber's H3 index. H3 is a geospatial indexing system using a hexagonal grid, with higher resolutions covering a larger area, and the smallest resolution covering centimeters of the earth. Helium uses the resolution 8. To give an idea, with this resolution, the earth is covered by 691,776,122 hexagons (see [here](https://h3geo.org/docs/core-library/restable/)). It is a bit too much to plot if we want to visualise this, that's why we will decrease the resolution to resolution 3 (41,162 hexagons) and then convert the H3 in latitude/longitude for plotting. Note that instead of downsizing the H3 resolution, we could convert the original H3 into lat/lng and bin the hotspots into hexagons ourselves ([link](https://stackoverflow.com/questions/39296198/operation-between-stat-summary-hex-plots-made-in-ggplot2/39300644)).

## Hotspot data
```{r}
### Retrieve info on the gateway
dataHotspot <- fread(file = "data/gateway_inventory_01213771.csv.gz") %>%
  select(address, owner, first_timestamp, location_hex) %>%
  rename(hotspot = address,
         firstDate = first_timestamp) %>%
  filter(location_hex != "", # remove hotspots without location
         firstDate != as.POSIXct("1970-01-01 00:00:00", tz = "UTC")) # a few hotspots appears to have been installed in 1970. This is obviously a mistake in the data base.

dataHotspot <- dataHotspot %>%
  mutate(data.frame(h3_to_geo(location_hex))) %>% # get the centers of the given H3 indexes
  mutate(h3LowRes = geo_to_h3(c(lat, lng), res = 3)) %>% # convert lat/lng to h3 resolution 2 
  mutate(data.frame(h3_to_geo(h3LowRes))) # get the centers of H3 
```

## Combine all data

```{r}
dataPacketsWithLocation <- inner_join(dataPackets, dataHotspot) # combine the two dataset by keeping all rows both in X and Y
```

# Results

## Hotspot statistics and visualisation

First info we can get is the number of hotspot per owner. 
```{r}
nHotspotsPerOwner <- dataHotspot %>% 
  group_by(owner) %>%
  summarise(count = n()) %>%
  arrange(desc(count))

nHotspotsPerOwner
```

If we plot an histogram of the count, it will be difficult to visualize anything. Indeed, the distribution is hyper skewed. Most owner have only 1-2 hotspots but some have more than 100, up to 2000 (who are they?). To visualize the distribution, we will here restrict the the number of owner with less than 100 hotspots.
```{r}
ggplot(filter(nHotspotsPerOwner, count <= 100), aes(count)) +
   geom_histogram(bins = 100) +
   scale_y_continuous(trans='log10') 
```

We can also visualize the growth of the network in terms of number of hotspots. 

```{r}
nHotspotsPerDate <- dataHotspot %>% 
  group_by(firstDate) %>%
  summarise(count = n()) 

ggplot(nHotspotsPerDate, aes(x = firstDate, y = cumsum(count))) +
  geom_line() +
  labs(title = "Growth of the hotspots", 
       y = "Total number of hotspot",
       x = "First apparition on the network") +
  scale_y_continuous(labels = function(x) format(x, scientific = FALSE),
                     breaks = seq(0, 5*10^5, length = 6))
```

Now we can visualise the growth of the network in terms of hotspots. Let's start by creating an empty world map.

```{r}
world <- map_data("world")
map <- ggplot() +
  geom_map(
    data = world, map = world,
    aes(long, lat, map_id = region)
  ) 
  
map
```






The client is the hotspot that witnessed the data packet and the owner is the wallet that paid for the data packet.


Now we will overlay the Helium data:

https://stackoverflow.com/questions/46556375/how-to-convert-x-y-coordinates-to-hexbin-center-coordinates

```{r}
makeHexData <- function(df) {
 h <- hexbin(df$lng, df$lat, nbins, xbnds = xbnds, ybnds = ybnds, IDs = TRUE)
 data.frame(hcell2xy(h),
            bytesPerDay = tapply(df$bytes, h@cID, FUN = function(z) sum(z)),
            cid = h@cell)
}

## find the bounds for the complete data
xbnds <- range(dataPacketsWithLocation$lng)
ybnds <- range(dataPacketsWithLocation$lat)
nbins <- 100

dataHexagon2 <- dataPacketsWithLocation %>%
  group_by(date) %>%
  group_modify(~ makeHexData(.x))

pBytesPerDay <- map +
    geom_hex(aes(x = x, y = y, fill = log10(bytesPerDay)),
             stat = "identity", 
             alpha = 0.8,
             data = dataHexagon2[c(1000:1010),]) +
    scale_fill_gradientn (colours = c("green","red")) 

anim <- pBytesPerDay + 
  transition_states(as.factor(date)) +
  labs(title = "Date: {closest_state}",
          subtitle = 'Frame {frame} of {nframes}') 

animate(anim)

dataHexagon <- dataPacketsWithLocation %>%
  group_by(date, lat, lng) %>%
  summarise(bytesPerDay = sum(bytes))

pBytesPerDay <- map +
    geom_hex(aes(x = lng, y = lat, fill = log10(bytesPerDay)),
             stat = "identity", 
             alpha = 0.8,
             data = dataHexagon[c(1000:1010),]) +
    scale_fill_gradientn (colours = c("green","red")) 

anim <- pBytesPerDay + 
  transition_states(as.factor(date)) +
  labs(title = "Date: {closest_state}",
          subtitle = 'Frame {frame} of {nframes}') 

animate(anim)
```



```{r}

```



https://aberdeenstudygroup.github.io/studyGroup/lessons/Visualising%20Spatial%20Data/Visualising_Spatial_Data_in_R/
https://ghanadatastuff.com/post/3d_population_density/

```{r}
mapScatter <- map +
  geom_point(
    data = dataCreditWithLocation[1:10000,],
    aes(Long, Lat),
    color = "green",
    alpha = 0.7, 
    size = 0.01)

mapPolygon <- map +
  stat_density_2d(
    data = dataCreditWithLocation[1:10000,],
    aes(x = Long, y = Lat, fill = ..level..),
    geom = "polygon") + scale_fill_gradient2(low = "blue", 
                       mid = "green", 
                       high = "red")
mapPolygon
```

```{r}
# 
# fig <-  plot_ly(
#     type = 'densitymapbox',
#     lat = ~Lat,
#     lon = ~Long,
#     z = ~ Packets,
#     frame = ~Time,
#     coloraxis = 'coloraxis',
#     data = dataCreditWithLocation[1:100000,],
#     radius = 1) %>%
#   layout(
#     mapbox = list(
#       style="stamen-terrain",
#       center= list(lon=180)), 
#     coloraxis = list(colorscale = "Viridis"))
# 
# fig
# 
# fig <-  plot_ly(
#     type = 'scattermapbox',
#     lat = ~Lat,
#     lon = ~Long,
#     frame = ~Time,
#     color = ~log(Packets),
#     data = dataCreditWithLocation[1:100000,]) %>%
#   layout(
#     mapbox = list(
#       style="stamen-terrain"))
# 
# fig
```

If you wish to help us continue researching and writting about data science on blockchain, don't hesitate to make a donation to our Ethereum address (0xf5fC137E7428519969a52c710d64406038319169) or Tezos address (tz1ffZLHbu9adcobxmd411ufBDcVgrW14mBd).

# References

<https://datavizpyr.com/how-to-make-world-map-with-ggplot2-in-r/>
https://towardsdatascience.com/exploring-the-helium-network-with-graph-theory-66cbb8bffff9
<https://docs.helium.com/>